// MODULES //

import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { TransitionGroup } from 'react-transition-group';
import * as d3 from 'd3';
import { select, zoom, event } from 'd3';
import copy from '@stdlib/utils/copy';
import deepEqual from '@stdlib/assert/deep-equal';
import uuid from 'uuid';
import Node from '../node';
import Link from '../link';
import './style.css';


// FUNCTIONS //

/**
* Sets the initial tree depth.
*
* @param {array} nodeSet - Array of nodes generated by `generateTree`
* @param {number} initialDepth - Maximum initial depth the tree should render
*
* @return {void}
*/
function setInitialTreeDepth( nodeSet, initialDepth ) {
	nodeSet.forEach( n => {
		n._collapsed = n.depth >= initialDepth;
	});
}

/**
* If `props.zoomable`, binds a listener for
* "zoom" events to the SVG and sets scaleExtent to min/max
* specified in `props.scaleExtent`.
*
* @return {void}
*/
function bindZoomListener(props) {
	const { zoomable, scaleExtent } = props;
	const svg = select( '.rd3t-svg' );
	const g = select( '.rd3t-g' );
	if ( zoomable ) {
		svg.call(
			zoom()
				.scaleExtent([ scaleExtent.min, scaleExtent.max ])
				.on( 'zoom', () => {
					g.attr(
						'transform',
						`translate(${
							event.transform.x + ',' + event.transform.y}) scale(${event.transform.k})`,
					);
				})
		);
	}
}

/**
* Sets the `_collapsed` property of
* the passed `node` object to `false`.
*
* @param {type} node Node object with custom properties
*
* @return {void}
*/
function expandNode( node ) {
	node._collapsed = false;
}


// MAIN //

class Tree extends Component {
	constructor(props) {
		super(props);
		this.state = {
			initialRender: true,
			data: this.assignInternalProperties( copy( props.data ) )
		};
		this.findNodesById = this.findNodesById.bind(this);
		this.collapseNode = this.collapseNode.bind(this);
		this.handleNodeToggle = this.handleNodeToggle.bind(this);
		this.handleOnClickCb = this.handleOnClickCb.bind(this);
	}

	componentDidMount() {
		bindZoomListener(this.props);
		// TODO find better way of setting initialDepth, re-render here is sub-optimal
		this.setState({ initialRender: false }); // eslint-disable-line
	}

	componentDidUpdate( prevProps ) {
		// Clone new data & assign internal properties
		if (!deepEqual(this.props.data, prevProps.data)) {
			this.setState({
				data: this.assignInternalProperties( copy( this.props.data ) )
			});
		}

		// If zoom-specific props change -> rebind listener with new values
		if (
			!deepEqual(this.props.translate, prevProps.translate) ||
			!deepEqual(this.props.scaleExtent, prevProps.scaleExtent)
		) {
			bindZoomListener( this.props );
		}
	}

	/**
	* Assigns internal properties to each node in the
	* `data` set that are required for tree manipulation and returns
	* a new `data` array.
	*
	* @param {array} data Hierarchical tree data
	*
	* @return {array} `data` array with internal properties added
	*/
	assignInternalProperties( data ) {
		const out = data.map( node => {
			node.id = uuid.v4();
			node._collapsed = false;
			// If there are children, recursively assign properties to them too
			if ( node.children && node.children.length > 0 ) {
				node.children = this.assignInternalProperties( node.children );
				node._children = node.children;
			}
			return node;
		});
		return out;
	}

	/**
	* `findNodesById` - Description
	*
	* @param {string} nodeId The `node.id` being searched for
	* @param {array} nodeSet Array of `node` objects
	* @param {array} hits Accumulator for matches, passed between recursive calls
	*
	* @return {array} Set of nodes matching `nodeId`
	*/
	// TODO Refactor this into a more readable/reasonable recursive depth-first walk.
	findNodesById(nodeId, nodeSet, hits) {
		if (hits.length > 0) {
			return hits;
		}

		hits = hits.concat(nodeSet.filter(node => node.id === nodeId));

		nodeSet.forEach(node => {
			if (node._children && node._children.length > 0) {
				hits = this.findNodesById(nodeId, node._children, hits);
				return hits;
			}
			return hits;
		});
		return hits;
	}

	/**
	* Recursively sets the `_collapsed` property of
	* the passed `node` object and its children to `true`.
	*
	* @param {object} node Node object with custom properties
	*
	* @return {void}
	*/
	collapseNode( node ) {
		node._collapsed = true;
		if ( node._children && node._children.length > 0 ) {
			node._children.forEach( child => {
				this.collapseNode( child );
			});
		}
	}

	/**
	* Finds the node matching `nodeId` and
	* expands/collapses it, depending on the current state of
	* its `_collapsed` property.
	* `setState` callback receives targetNode and handles
	* `props.onClick` if defined.
	*
	* @param {string} nodeId A node object's `id` field.
	*
	* @return {void}
	*/
	handleNodeToggle( nodeId ) {
		const data = copy( this.state.data );
		const matches = this.findNodesById( nodeId, data, []);
		const targetNode = matches[ 0 ];

		if ( this.props.collapsible ) {
			if ( targetNode._collapsed ) {
				expandNode( targetNode );
			}
			else {
				this.collapseNode( targetNode );
			}
			this.setState({ data }, () => this.handleOnClickCb( targetNode ) );
		} else {
			this.handleOnClickCb( targetNode );
		}
	}

	/**
	* Handles the user-defined `onClick` function
	*
	* @param {object} targetNode Description
	*
	* @return {void}
	*/
	handleOnClickCb( targetNode ) {
		const { onClick } = this.props;
		if ( onClick && typeof onClick === 'function' ) {
			onClick( copy( targetNode ) );
		}
	}

	/**
	* Generates tree elements (`nodes` and `links`) by
	* grabbing the rootNode from `this.state.data[0]`.
	* Restricts tree depth to `props.initialDepth` if defined and if this is
	* the initial render of the tree.
	*
	* @return {object} Object containing `nodes` and `links`.
	*/
	generateTree() {
		const {
			initialDepth,
			depthFactor,
			separation,
			nodeSize,
			orientation
		} = this.props;

		var data = d3.hierarchy( copy( this.state.data )[ 0 ], d => ( d._collapsed ? null : d._children ) );

		const tree = d3
			.tree()
			.nodeSize(
				orientation === 'horizontal' ?
					[ nodeSize.y, nodeSize.x ] :
					[ nodeSize.x, nodeSize.y ],
			)
			.separation(
				( a, b ) =>
					deepEqual( a.parent, b.parent ) ?
						separation.siblings :
						separation.nonSiblings,
			);

		const root = tree( data );
		const nodes = root.descendants();
		const links = root.links();

		// Set `initialDepth` on first render if specified
		if ( initialDepth !== void 0 && this.state.initialRender ) {
			setInitialTreeDepth( nodes, initialDepth );
		}

		if ( depthFactor ) {
			nodes.forEach( node => {
				node.y = node.depth * depthFactor;
			});
		}

		return { nodes, links };
	}

	render() {
		const { nodes, links } = this.generateTree();
		const {
			nodeSvgShape,
			orientation,
			translate,
			pathFunc,
			transitionDuration,
			zoomable,
			textLayout,
			circleRadius,
			styles
		} = this.props;

		return (
			<div
				className={`rd3t-tree-container ${zoomable ? 'rd3t-grabbable' : void 0}`}
			>
				<svg className="rd3t-svg" width="100%" height="100%">
					<TransitionGroup
						component="g"
						className="rd3t-g"
						transform={`translate(${translate.x},${translate.y})`}
					>
						{links.map( linkData => (
							<Link
								key={uuid.v4()}
								orientation={orientation}
								pathFunc={pathFunc}
								linkData={linkData}
								transitionDuration={transitionDuration}
								styles={styles.links}
							/>
						))}

						{nodes.map( nodeData => (
							<Node
								key={nodeData.data.id}
								nodeSvgShape={nodeSvgShape}
								orientation={orientation}
								transitionDuration={transitionDuration}
								nodeData={nodeData}
								name={nodeData.data.name}
								attributes={nodeData.data.attributes}
								onClick={this.handleNodeToggle}
								textLayout={textLayout}
								circleRadius={circleRadius}
								styles={styles.nodes}
							/>
						))}
					</TransitionGroup>
				</svg>
			</div>
		);
	}
}


// TYPES //

Tree.defaultProps = {
	nodeSvgShape: {
		shape: 'circle',
		shapeProps: {
			r: 10
		}
	},
	onClick: void 0,
	orientation: 'horizontal',
	translate: { x: 0, y: 0 },
	pathFunc: 'diagonal',
	transitionDuration: 500,
	depthFactor: void 0,
	collapsible: true,
	initialDepth: void 0,
	zoomable: true,
	scaleExtent: { min: 0.1, max: 1 },
	nodeSize: { x: 140, y: 140 },
	separation: { siblings: 1, nonSiblings: 2 },
	textLayout: {
		textAnchor: 'start',
		x: 10,
		y: -10
	},
	circleRadius: void 0, // TODO: DEPRECATE
	styles: {}
};

Tree.propTypes = {
	circleRadius: PropTypes.number,
	collapsible: PropTypes.bool,
	data: PropTypes.array.isRequired,
	depthFactor: PropTypes.number,
	initialDepth: PropTypes.number,
	nodeSize: PropTypes.shape({
		x: PropTypes.number,
		y: PropTypes.number
	}),
	nodeSvgShape: PropTypes.shape({
		shape: PropTypes.string,
		shapeProps: PropTypes.object
	}),
	onClick: PropTypes.func,
	orientation: PropTypes.oneOf([ 'horizontal', 'vertical' ]),
	pathFunc: PropTypes.oneOfType([
		PropTypes.oneOf([ 'diagonal', 'elbow', 'straight' ]),
		PropTypes.func
	]),
	scaleExtent: PropTypes.shape({
		min: PropTypes.number,
		max: PropTypes.number
	}),
	separation: PropTypes.shape({
		siblings: PropTypes.number,
		nonSiblings: PropTypes.number
	}),
	styles: PropTypes.shape({
		nodes: PropTypes.object,
		links: PropTypes.object
	}),
	textLayout: PropTypes.object,
	transitionDuration: PropTypes.number,
	translate: PropTypes.shape({
		x: PropTypes.number,
		y: PropTypes.number
	}),
	zoomable: PropTypes.bool
};


// EXPORTS //

export default Tree;
