// MODULES //

import fs from 'fs-extra';
import path from 'path';
import webpack from 'webpack';
import UglifyJS from 'uglify-js';


// VARIABLES //

const GENERAL_REQUIRES = {
	Button: 'const Button = require( \'react-bootstrap\' ).Button;',
	CheckboxInput: 'const CheckboxInput = require( \'general/checkbox-input\' );',
	ColorPicker: 'const ColorPicker = require( \'general/color-picker\' );',
	Column: 'const Column = require( \'react-bootstrap\' ).Col;',
	Dashboard: 'const Dashboard = require( \'general/dashboard\' );',
	DraggableList: 'const DraggableList = require( \'general/draggable-list\' );',
	Grid: 'const Grid = require( \'general/grid\' );',
	LessonSubmit: 'const LessonSubmit = require( \'general/lesson-submit\' );',
	Nav: 'const Nav = require( \'react-bootstrap\' ).Nav;',
	NavItem: 'const NavItem = require( \'react-bootstrap\' ).NavItem;',
	NumberInput: 'const NumberInput = require( \'general/number-input\' );',
	Panel: 'const Panel = require( \'react-bootstrap\' ).Panel;',
	Row: 'const Row = require( \'react-bootstrap\' ).Row;',
	SelectInput: 'const SelectInput = require( \'general/select-input\' );',
	SliderInput: 'const SliderInput = require( \'general/slider-input\' );',
	Slider: 'const Slider = require( \'general/slider\' );',
	Tab: 'const Tab = require( \'react-bootstrap\' ).Tab;',
	Tabs:'const Tabs = require( \'react-bootstrap\' ).Tabs;',
	TextInput: 'const TextInput = require( \'general/text-input\' );',
	Timer: 'const Timer = require( \'general/timer\' );',
	Well: 'const Well = require( \'react-bootstrap\' ).Well;',
	VictoryAnimation: 'const VictoryAnimation = require( \'victory\' ).VictoryAnimation;',
	VictoryBar: 'const VictoryBar = require( \'victory\' ).VictoryBar;',
	VictoryTheme: 'const VictoryTheme = require( \'victory\' ).VictoryTheme;',
	VictoryChart: 'const VictoryChart = require( \'victory\' ).VictoryChart;',
	VictoryGroup: 'const VictoryGroup = require( \'victory\' ).VictoryGroup;',
	VictoryAxis: 'const VictoryAxis = require( \'victory\' ).VictoryAxis;',
	VictoryErrorBar: 'const VictoryErrorBar = require( \'victory\' ).VictoryErrorBar;',
	VictoryLine: 'const VictoryLine = require( \'victory\' ).VictoryLine;',
	VictoryTooltip: 'const VictoryTooltip = require( \'victory\' ).VictoryTooltip;'
};

const LEARNING_REQUIRES = {
	DensityPlot: 'const DensityPlot = require( \'learning/d3/density-plot\' );',
	FeedbackButtons: 'const FeedbackButtons = require( \'learning/feedback\' );',
	FreeTextQuestion: 'const FreeTextQuestion = require( \'learning/free-text-question\' );',
	FunctionPlot: 'const FunctionPlot = require( \'learning/function-plot\' );',
	MultipleChoiceQuestion: 'const MultipleChoiceQuestion = require( \'learning/multiple-choice-question\' );',
	RHelp: 'const RHelp = require( \'learning/rhelp\' );',
	RPlot: 'const RPlot = require( \'learning/r/plot\' );',
	RShell: 'const RShell = require( \'learning/rshell\' );',
	RTable: 'const RTable = require( \'learning/r/table\' );',
	TeX: 'const TeX = require( \'learning/tex\' );',
	Switch: 'Switch = require( \'learning/switch\' );',
	VideoPlayer: 'const VideoPlayer = require( \'learning/video-player\' );'
};

const isPackaged = !( /node_modules\/electron\/dist/.test( process.resourcesPath ) );
const rootPaths = [];
if ( isPackaged ) {
	rootPaths.push( `${process.resourcesPath}/app/node_modules` );
	rootPaths.push( `${process.resourcesPath}/app/app/components/node_modules/` );
	rootPaths.push( `${process.resourcesPath}/app/node_modules/@stdlib/stdlib/lib/node_modules` );
	rootPaths.push( `${process.resourcesPath}/app/node_modules/@stdlib/stdlib/node_modules` );
} else {
	rootPaths.push( path.resolve( './node_modules' ) );
	rootPaths.push( path.resolve( './node_modules/@stdlib/stdlib/lib/node_modules' ) );
	rootPaths.push( path.resolve( './node_modules/@stdlib/stdlib/node_modules' ) );
	rootPaths.push( path.resolve( './app/components/node_modules/' ) );
}


// CONFIG //

const config = {
	resolve: {
		root: rootPaths,
		alias: {
			'object-keys': isPackaged ? `${process.resourcesPath}/app/objectKeys.js` : path.resolve( './objectKeys.js' ),
			'victory': isPackaged ?
				`${process.resourcesPath}/app/node_modules/victory/dist/victory/`:
				path.resolve( './node_modules/victory/dist/victory/' )
		}
	},
	resolveLoader: {
		root: rootPaths
	},
	module: {
		loaders: [
			{
				test: /\.js?$/,
				loader: 'babel-loader',
				exclude: path.join( __dirname, 'node_modules' ),
				query: {
					plugins: [
						'add-module-exports'
					],
					presets: [
						'es2015',
						'react',
						'stage-0'
					],
					babelrc: false,
					cacheDirectory: true
				}
			},
			{
				test: /\.json$/,
				loader: 'json-loader'
			},
		],
		noParse: /node_modules\/json-schema\/lib\/validate\.js/
	},
	node: {
		dns: 'mock',
		fs: 'empty',
		net: 'mock',
		tls: 'mock'
	},
	plugins: [
		new webpack.DefinePlugin({
			'process.env': {
				NODE_ENV: '"production"'
			}
		}),
		new webpack.IgnorePlugin( /vertx/ ),
		new webpack.ProvidePlugin({
			'window.d3': 'd3'
		})
	],
	externals: [
		'crypto-browserify'
	]
};

// FUNCTIONS //

const contains = ( arr, value ) => {
	for ( let i = 0; i < arr.length; i++ ) {
		if ( arr[ i ] === value ) {
			return true;
		}
	}
	return false;
};

const generateIndexHTML = ( title, minify ) => `
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>${title}</title>
		<link href="css/katex.min.css" rel="stylesheet" />
		<link href="css/bootstrap.min.css" rel="stylesheet" />
		<link href="css/bootstrap-theme.min.css" rel="stylesheet" />
		<link href='https://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css' />
		<link href="css/fixed-data-table.min.css" rel="stylesheet" />
		<link href="css/slick.min.css" rel="stylesheet" type="text/css" />
		<link href="css/slick-theme.min.css" rel="stylesheet" type="text/css" />
		<link rel="stylesheet" href="css/lesson.css" />
	</head>
	<body>
	<div id="Lesson"></div>
	<script>
		// Handle bug occuring when crypto-browserify is used with Webpack...
		window._crypto = {};
	</script>
	<script src=${ minify ? "bundle.min.js" : "bundle.js" }></script>
	</body>
</html>
`;

const getMainImports = () => `
import React, { Component } from 'react';
import { render } from 'react-dom';
import assignMath from '@stdlib/namespace/lib/math';
import NotificationSystem from 'react-notification-system';

global.std = {};
assignMath( global.std );
`;

const getLearningComponents = ( arr ) => {
	const requireStatements = arr.map( elem => LEARNING_REQUIRES[ elem ]);
	return requireStatements.join( '\n' );
};

const getGeneralComponents = ( arr ) => {
	let requireStatements = [ 'const Input = require( \'general/input\' );' ];
	requireStatements = requireStatements.concat( arr.map( elem => GENERAL_REQUIRES[ elem ]) );
	return requireStatements.join( '\n' );
};

const getLessonComponent = ( lessonContent ) => `
class Lesson extends Component {
	componentDidMount() {
		global.lesson = this;
		this._notificationSystem = this.refs.notificationSystem;
		this.forceUpdate();
	}

	addNotification( config ) {
		this._notificationSystem.addNotification( config );
	}

	render() {
		return (
			<div>
				<div>${lessonContent}</div>
				<NotificationSystem ref="notificationSystem" allowHTML={true} />
			</div>
		);
	}
}

render(
	<Lesson />,
	document.getElementById( 'Lesson' )
);`;

const getComponentList = ( code ) => {
	const ret = [];
	const availableComponents = [
		'Button',
		'CheckboxInput',
		'ColorPicker',
		'Column',
		'Dashboard',
		'DensityPlot',
		'DraggableList',
		'FeedbackButtons',
		'FreeTextQuestion',
		'FunctionPlot',
		'Grid',
		'LessonSubmit',
		'MultipleChoiceQuestion',
		'Nav',
		'NavItem',
		'NumberInput',
		'Panel',
		'RHelp',
		'RPlot',
		'Row',
		'RShell',
		'RTable',
		'SelectInput',
		'SliderInput',
		'Slider',
		'Tab',
		'Tabs',
		'TeX',
		'TextInput',
		'Timer',
		'Switch',
		'Well',
		'VideoPlayer',
		'VictoryAnimation',
		'VictoryBar',
		'VictoryTheme',
		'VictoryChart',
		'VictoryGroup',
		'VictoryAxis',
		'VictoryErrorBar',
		'VictoryLine',
		'VictoryTooltip'
	];

	for ( let i = 0; i < availableComponents.length; i++ ) {
		const regexp = new RegExp( `<${availableComponents[ i ]}[^>]*>`, 'gi' );
		if ( regexp.test( code ) === true ) {
			ret.push( availableComponents[ i ]);
		}
	}
	return ret;
};

const getISLEcode = ( meta ) => 'global.ISLE = ' + JSON.stringify( meta ) + ';';

const getSessionCode = () => {
	let str = 'const Session = ';
	str += isPackaged ?
		`require( '${process.resourcesPath}/app/app/api/session' );` :
		`require( '${path.resolve( './app/api/session' )}' );`;
	str += 'global.ISLE.session = new Session( global.ISLE );';
	return str;
};

const getMailCode = () => `
import request from 'request';
import mustache from 'mustache';
global.ISLE.sendMail = function sendMail( name, to ) {
	var mailOptions = global.ISLE.mails[ name ];
	if ( !mailOptions.hasOwnProperty( 'from' ) ) {
		mailOptions.from = ISLE.email || 'robinson@isle.cmu.edu';
	}
	if ( mailOptions.hasOwnProperty( 'text' ) ) {
		mailOptions.text = mustache.render( mailOptions.text, global );
	}
	mailOptions.to = to;
	request.post( ISLE.server + '/mail', {
		form: mailOptions
	}, ( error, response, body ) => {
		console.log( error );
	});
};`;


// MAIN //

/**
* Generate contents of index.js file of lesson.
*
* @param {string} lessonContent - ISLE lesson file
* @param {Array} components - array of component names
* @param {Object} meta - lesson meta data
* @returns {string} index.js content
*/
function generateIndexJS( lessonContent, components, meta ) {
	let res = getMainImports();
	res += '\n';
	res += getISLEcode( meta );
	res += 'global.store = global.ISLE.store;';
	if ( meta.server ) {
		res += getSessionCode();
	}
	if ( meta.mails ) {
		res += getMailCode();
	}
	res += getGeneralComponents( components );
	res += getLearningComponents( components );
	res += getLessonComponent( lessonContent );
	return res;
} // end FUNCTION generateIndexJS()

/**
* Write index.js file to disk
*
* @param {string} outputPath - file path of output directory
* @param {string} lessonContent - ISLE lesson file
* @param {Object} meta - lesson meta data
* @param {boolean} minify - boolean indicating whether code should be minified
* @param {Function} clbk - callback function
*/
function writeIndexFile( outputPath, lessonContent, meta, minify, clbk ) {
	const appDir = path.join( outputPath, meta.title );
	const indexPath = isPackaged ?
		`${process.resourcesPath}/app/public/index.js` :
		path.resolve( './public/index.js' );
	const htmlPath = path.join( appDir, 'index.html' );
	const bundlePath = path.join( appDir, 'bundle.js' );
	const getCSSPath = () => {
		return isPackaged ?
		`${process.resourcesPath}/app/app/css/` :
		path.resolve( `./app/css/` );
	};

	const usedComponents = getComponentList( lessonContent );

	const str = generateIndexJS( lessonContent, usedComponents, meta );

	fs.writeFileSync( indexPath, str );

	// Copy CSS files:
	fs.copySync( getCSSPath(), path.join( appDir, 'css/' ) );

	if ( contains( usedComponents, 'FeedbackButtons' ) ) {
		fs.mkdirSync( path.join( appDir, 'img' ) );
		let imgPath = isPackaged ?
			`${process.resourcesPath}/app/app/img` :
			path.resolve( './app/img' );
		fs.copySync( path.join( imgPath, 'confused.svg' ), path.join( appDir, 'img', 'confused.svg' ) );
		fs.copySync( path.join( imgPath, 'feedback.svg' ), path.join( appDir, 'img', 'feedback.svg' ) );
		fs.copySync( path.join( imgPath, 'lightbulb.svg' ), path.join( appDir, 'img', 'lightbulb.svg' ) );
	}

	config.entry = indexPath;
	config.output = {
		path: appDir,
		filename: 'bundle.js'
	};
	const compiler = webpack( config );

	compiler.run( ( err, stats ) => {
		if ( err ) {
			throw err;
		}
		console.log( stats );
		fs.unlinkSync( indexPath );
		fs.writeFileSync( htmlPath, generateIndexHTML( meta.title, minify ) );

		if ( minify ) {
			const minified = UglifyJS.minify( bundlePath, {
				warnings: false,
				compress: true,
				mangle: true
			});
			fs.writeFileSync( path.join( appDir, 'bundle.min.js' ), minified.code );
		}
		clbk( err );
	});
} // end FUNCTION writeIndexFile()


// EXPORTS //

module.exports = writeIndexFile;
